<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS 180 Project 3 - Face Morphing and Modelling a Photo Collection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        header {
            text-align: center;
            margin-bottom: 50px;
            padding: 40px 0;
            border-bottom: 3px solid #667eea;
        }

        h1 {
            font-size: 2.8em;
            font-weight: 300;
            color: #2c3e50;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .subtitle {
            font-size: 1.2em;
            color: #7f8c8d;
            font-weight: 300;
        }

        .section {
            margin-bottom: 60px;
            padding: 30px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .section-title {
            font-size: 2.2em;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            position: relative;
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 2px;
        }

        .subsection-title {
            font-size: 1.6em;
            color: #2c3e50;
            margin: 30px 0 15px 0;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }

        .description {
            font-size: 1.1em;
            color: #555;
            margin-bottom: 30px;
            text-align: justify;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        .approach-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin: 25px 0;
            border-left: 4px solid #3498db;
        }

        .approach-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .approach-section p {
            margin-bottom: 10px;
        }

        .approach-section ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .approach-section li {
            margin-bottom: 5px;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin: 30px 0;
        }

        .image-grid-2 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin: 30px 0;
        }

        .image-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            margin: 30px 0;
        }

        .image-container {
            text-align: center;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .image-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15);
        }

        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s ease;
        }

        .image-container img:hover {
            transform: scale(1.02);
        }

        .image-label {
            font-size: 1.1em;
            font-weight: 600;
            color: #2c3e50;
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .image-description {
            font-size: 0.95em;
            color: #666;
            font-style: italic;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
            margin: 20px 0;
            overflow-x: auto;
        }

        .highlight {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-top: 20px;
            font-size: 1.05em;
            line-height: 1.7;
        }

        .highlight h3 {
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
            align-items: center;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }

            h1 {
                font-size: 2.2em;
            }

            .image-grid,
            .image-grid-2,
            .image-grid-3 {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .section {
                padding: 20px;
            }

            .section-title {
                font-size: 1.8em;
            }
        }

        footer {
            text-align: center;
            padding: 30px 0;
            color: #7f8c8d;
            border-top: 2px solid #ecf0f1;
            margin-top: 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>CS 180 Project 3</h1>
            <p class="subtitle">Image Warping and Mosaicing</p>
        </header>

        <!-- Project Overview -->
        <section class="section">
            <h2 class="section-title">Project Overview</h2>
            <p class="description">
                This project explores image warping and mosaicing through the computation and application of homographies. 
                The goal is to take multiple photographs with projective transformations between them and create seamless 
                panoramic mosaics. Key techniques include computing homographies from point correspondences, implementing 
                image warping with different interpolation methods, and blending images to create visually appealing panoramas. 
                Along the way, we also demonstrate image rectification by transforming perspective-distorted rectangular objects 
                back to their proper rectangular form.
            </p>
        </section>

        <!-- Part A.1: Shoot the Pictures -->
        <section class="section">
            <h2 class="section-title">A.1: Shoot the Pictures</h2>
            <p class="description">
                I captured three sets of photographs with projective transformations between them by fixing the center of 
                projection and rotating the camera. Each set has significant overlap (40-70%) to facilitate accurate registration 
                and blending. The scenes include indoor spaces with rich detail and geometric structure.
            </p>

            <div class="subsection-title">Image Set 1: Bathroom Panorama</div>
            <div class="image-grid-2">
                <div class="image-container">
                    <img src="media/bathroom_left.jpg" alt="Bathroom left view">
                    <div class="image-label">Bathroom Left</div>
                    <div class="image-description">Left view of bathroom with mirror and fixtures</div>
                </div>
                <div class="image-container">
                    <img src="media/bathroom_right.jpg" alt="Bathroom right view">
                    <div class="image-label">Bathroom Right</div>
                    <div class="image-description">Right view with overlapping field of view</div>
                </div>
            </div>

            <div class="subsection-title">Image Set 2: Kitchen Panorama</div>
            <div class="image-grid-2">
                <div class="image-container">
                    <img src="media/kitchen_left.jpg" alt="Kitchen left view">
                    <div class="image-label">Kitchen Left</div>
                    <div class="image-description">Left view of kitchen with cabinets</div>
                </div>
                <div class="image-container">
                    <img src="media/kitchen_right.jpg" alt="Kitchen right view">
                    <div class="image-label">Kitchen Right</div>
                    <div class="image-description">Right view with stove and countertops</div>
                </div>
            </div>

            <div class="subsection-title">Image Set 3: Gate Panorama</div>
            <div class="image-grid-2">
                <div class="image-container">
                    <img src="media/gate_left.jpg" alt="Gate left view">
                    <div class="image-label">Gate Left</div>
                    <div class="image-description">Left view of decorative gate</div>
                </div>
                <div class="image-container">
                    <img src="media/gate_right.jpg" alt="Gate right view">
                    <div class="image-label">Gate Right</div>
                    <div class="image-description">Right view with overlapping architecture</div>
                </div>
            </div>

            <div class="approach-section">
                <h3>Photography Guidelines Followed</h3>
                <ul>
                    <li><strong>Fixed Center of Projection:</strong> Camera was rotated around a fixed point to ensure projective transformations</li>
                    <li><strong>Significant Overlap:</strong> 50-60% overlap between consecutive images for robust feature matching</li>
                    <li><strong>Consistent Lighting:</strong> All images in each set captured quickly to maintain consistent lighting conditions</li>
                    <li><strong>Rich Detail:</strong> Chose scenes with geometric features and texture for easier correspondence identification</li>
                    <li><strong>Straight Lines:</strong> Avoided fisheye distortion by using standard focal length</li>
                </ul>
            </div>
        </section>

        <!-- Part A.2: Recover Homographies -->
        <section class="section">
            <h2 class="section-title">A.2: Recover Homographies</h2>
            <p class="description">
                To align images, we need to compute the homography matrix H that maps points from one image to another. 
                A homography is a 3×3 matrix with 8 degrees of freedom that represents a projective transformation. 
                Given n point correspondences, we can set up a system of linear equations and solve for H using least-squares.
            </p>

            <div class="approach-section">
                <h3>Homography Mathematics</h3>
                <p>For each correspondence (x, y) in image 1 → (u, v) in image 2, the homography relationship is:</p>
                <div class="code-block">
u = (h₁₁x + h₁₂y + h₁₃) / (h₃₁x + h₃₂y + 1)
v = (h₂₁x + h₂₂y + h₂₃) / (h₃₁x + h₃₂y + 1)</div>
                <p>Rearranging into linear form gives us 2 equations per point correspondence:</p>
                <div class="code-block">
-x·h₁₁ - y·h₁₂ - h₁₃ + u·x·h₃₁ + u·y·h₃₂ + u = 0
-x·h₂₁ - y·h₂₂ - h₂₃ + v·x·h₃₁ + v·y·h₃₂ + v = 0</div>
                <p>With n correspondences, we get a 2n × 8 system Ah = b, solved using least-squares: h = (AᵀA)⁻¹Aᵀb</p>
            </div>

            <div class="subsection-title">Point Correspondences Visualization</div>
            
            <div class="image-container" style="margin: 30px 0;">
                <img src="media/bathroom_correspondences.png" alt="Bathroom correspondences">
                <div class="image-label">Bathroom Panorama Correspondences</div>
                <div class="image-description">8 manually selected point pairs (color-coded) used to compute homography</div>
            </div>

            <div class="image-container" style="margin: 30px 0;">
                <img src="media/kitchen_correspondences.png" alt="Kitchen correspondences">
                <div class="image-label">Kitchen Panorama Correspondences</div>
                <div class="image-description">Point pairs selected on distinctive features like cabinet edges and appliances</div>
            </div>

            <div class="image-container" style="margin: 30px 0;">
                <img src="media/gate_correspondences.png" alt="Gate correspondences">
                <div class="image-label">Gate Panorama Correspondences</div>
                <div class="image-description">Correspondences on architectural features and decorative elements</div>
            </div>

            <div class="approach-section">
                <h3>Implementation Details</h3>
                <p><strong>Point Selection:</strong> Used manual correspondence tool to select 8-12 point pairs per image set, 
                focusing on distinctive corners, edges, and high-contrast features.</p>
                <p><strong>Overdetermined System:</strong> Using more than 4 points (minimum required) makes the system more 
                robust to noise and small errors in point selection.</p>
                <p><strong>Least-Squares Solution:</strong> Implemented using numpy.linalg.lstsq() which handles overdetermined 
                systems efficiently and provides residual information.</p>
                <p><strong>Coordinate Convention:</strong> Used (x, y) convention where x is horizontal and y is vertical, 
                with origin at top-left corner.</p>
            </div>
        </section>

        <!-- Part A.3: Warp the Images -->
        <section class="section">
            <h2 class="section-title">A.3: Warp the Images</h2>
            <p class="description">
                With the homography computed, we can now warp images to align them. I implemented two interpolation methods 
                from scratch: nearest neighbor and bilinear interpolation. Both use inverse warping to avoid holes in the output.
            </p>

            <div class="approach-section">
                <h3>Inverse Warping Algorithm</h3>
                <p><strong>1. Compute Output Bounds:</strong> Transform the four corners of the source image through H to determine output size</p>
                <p><strong>2. Create Output Grid:</strong> Generate a meshgrid of coordinates for the output image</p>
                <p><strong>3. Map to Source:</strong> For each output pixel, apply H⁻¹ to find corresponding source location</p>
                <p><strong>4. Interpolate:</strong> Sample the source image at the computed location using chosen interpolation method</p>
                <p><strong>5. Handle Boundaries:</strong> Only copy pixels that map to valid source coordinates</p>
            </div>

            <div class="approach-section">
                <h3>Interpolation Trade-offs</h3>
                <p><strong>Nearest Neighbor:</strong></p>
                <ul>
                    <li>Pros: Very fast (just round coordinates), simple implementation, preserves exact pixel values</li>
                    <li>Cons: Produces blocky/pixelated artifacts, visible aliasing, poor quality for large transformations</li>
                    <li>Use case: Quick previews, pixel art, when exact values must be preserved</li>
                </ul>
                <p><strong>Bilinear Interpolation:</strong></p>
                <ul>
                    <li>Pros: Smooth results, good quality, reasonable computational cost</li>
                    <li>Cons: Slightly slower (4 pixel lookups + weighted average), can blur sharp edges</li>
                    <li>Use case: Final output, photographic images, when quality matters</li>
                </ul>
            </div>

            <div class="subsection-title">Rectification Examples</div>
            <p class="description">
                Before creating full mosaics, I tested the warping pipeline by rectifying perspective-distorted rectangular 
                objects. This involves defining correspondences between the distorted quadrilateral in the image and a perfect 
                rectangle, then applying the computed homography. The images below show comparisons of nearest neighbor vs. 
                bilinear interpolation for both rectification examples.
            </p>

            <div class="image-container" style="margin: 30px 0;">
                <img src="media/cabinet_rectified.png" alt="Cabinet rectification comparison">
                <div class="image-label">Cabinet Rectification</div>
                <div class="image-description">
                    Original perspective-distorted cabinet door (left), rectified with nearest neighbor (center), 
                    and rectified with bilinear interpolation (right). Bilinear produces smoother, higher-quality results.
                </div>
            </div>

            <div class="image-container" style="margin: 30px 0;">
                <img src="media/trackpad_rectified.png" alt="Trackpad rectification comparison">
                <div class="image-label">Trackpad Rectification</div>
                <div class="image-description">
                    Original angled trackpad view (left), rectified with nearest neighbor (center), 
                    and rectified with bilinear interpolation (right). Notice the smoother edges with bilinear interpolation.
                </div>
            </div>

            <div class="approach-section">
                <h3>Rectification Process</h3>
                <p><strong>1. Identify Rectangle:</strong> Manually select the four corners of a known rectangular object in the image</p>
                <p><strong>2. Define Target:</strong> Create ideal rectangle coordinates (e.g., [0,0], [0,h], [w,h], [w,0])</p>
                <p><strong>3. Compute Homography:</strong> Use computeH() with source corners → target corners</p>
                <p><strong>4. Warp Image:</strong> Apply homography to transform the perspective-distorted view to frontal view</p>
                <p><strong>Result:</strong> The rectangular object appears as if viewed directly from the front, removing perspective distortion</p>
            </div>
        </section>

        <!-- Part A.4: Blend into Mosaic -->
        <section class="section">
            <h2 class="section-title">A.4: Blend the Images into a Mosaic</h2>
            <p class="description">
                The final step is to blend the warped images into seamless panoramic mosaics. Simple overwriting creates 
                harsh edge artifacts, so I implemented weighted averaging with distance-based blending to create smooth transitions 
                in overlapping regions.
            </p>

            <div class="approach-section">
                <h3>Blending Algorithm</h3>
                <p><strong>1. Warp Images:</strong> Transform one or more images to align with a reference frame</p>
                <p><strong>2. Compute Canvas Size:</strong> Determine bounding box that fits all images</p>
                <p><strong>3. Distance-Based Weights:</strong> For each image, compute weight based on distance from center:
                   weight = max(0, 1 - max(dist_x, dist_y))</p>
                <p><strong>4. Accumulate Weighted Pixels:</strong> For each pixel position, accumulate color × weight and total weight</p>
                <p><strong>5. Normalize:</strong> Divide accumulated color by total weight to get final blended value</p>
                <p><strong>Result:</strong> Smooth transitions in overlap regions, no visible seams</p>
            </div>

            <div class="subsection-title">Mosaic 1: Bathroom Panorama</div>
            
            <div class="image-grid-2">
                <div class="image-container">
                    <img src="media/bathroom_left.jpg" alt="Bathroom left source">
                    <div class="image-label">Source Image 1</div>
                </div>
                <div class="image-container">
                    <img src="media/bathroom_right.jpg" alt="Bathroom right source">
                    <div class="image-label">Source Image 2</div>
                </div>
            </div>

            <div class="image-container" style="margin: 30px 0;">
                <img src="media/bathroom_mosaic.png" alt="Bathroom mosaic result">
                <div class="image-label">Bathroom Panorama Result</div>
                <div class="image-description">
                    Seamless blend of two views creating a wide-angle bathroom panorama. 
                    Weighted blending eliminates visible seams in the mirror and tile regions.
                </div>
            </div>

            <div class="subsection-title">Mosaic 2: Kitchen Panorama</div>
            
            <div class="image-grid-2">
                <div class="image-container">
                    <img src="media/kitchen_left.jpg" alt="Kitchen left source">
                    <div class="image-label">Source Image 1</div>
                </div>
                <div class="image-container">
                    <img src="media/kitchen_right.jpg" alt="Kitchen right source">
                    <div class="image-label">Source Image 2</div>
                </div>
            </div>

            <div class="image-container" style="margin: 30px 0;">
                <img src="media/kitchen_mosaic.png" alt="Kitchen mosaic result">
                <div class="image-label">Kitchen Panorama Result</div>
                <div class="image-description">
                    Wide-angle kitchen view combining cabinets, countertops, and appliances. 
                    The blending successfully handles the complex geometry of cabinet doors and edges.
                </div>
            </div>

            <div class="subsection-title">Mosaic 3: Gate Panorama</div>
            
            <div class="image-grid-2">
                <div class="image-container">
                    <img src="media/gate_left.jpg" alt="Gate left source">
                    <div class="image-label">Source Image 1</div>
                </div>
                <div class="image-container">
                    <img src="media/gate_right.jpg" alt="Gate right source">
                    <div class="image-label">Source Image 2</div>
                </div>
            </div>

            <div class="image-container" style="margin: 30px 0;">
                <img src="media/gate_mosaic.jpg" alt="Gate mosaic result">
                <div class="image-label">Gate Panorama Result</div>
                <div class="image-description">
                    Panoramic view of decorative gate architecture. The weighted blending preserves 
                    the intricate details of the metalwork while creating smooth transitions.
                </div>
            </div>

            <div class="approach-section">
                <h3>Blending Procedure Details</h3>
                <p><strong>Reference Frame Selection:</strong> I kept one image (typically the left) as the reference and warped 
                the other image(s) into its coordinate system.</p>
                <p><strong>Weight Function:</strong> Used distance from image center as the weight function. Pixels near the center 
                of each image have weight ≈ 1, falling off linearly to 0 at the edges.</p>
                <p><strong>Overlap Handling:</strong> In regions where images overlap, the final color is a weighted average of 
                both images, creating a smooth transition.</p>
                <p><strong>Canvas Management:</strong> Computed the bounding box of all warped images to create a canvas large 
                enough to hold the entire panorama.</p>
                <p><strong>Alpha Handling:</strong> Tracked which pixels have valid data using the weight accumulation, avoiding 
                artifacts from empty regions.</p>
            </div>

            <div class="approach-section">
                <h3>Challenges and Solutions</h3>
                <p><strong>Challenge 1 - Edge Artifacts:</strong> Simple overwriting creates visible seams.</p>
                <p><strong>Solution:</strong> Implemented distance-based weighted blending that smoothly transitions between images.</p>
                
                <p><strong>Challenge 2 - Coordinate System Management:</strong> Warped images can have negative coordinates.</p>
                <p><strong>Solution:</strong> Applied translation matrix to shift all coordinates to positive values before compositing.</p>
                
                <p><strong>Challenge 3 - Interpolation Artifacts:</strong> Nearest neighbor creates blocky results.</p>
                <p><strong>Solution:</strong> Used bilinear interpolation for final mosaics to ensure smooth, high-quality output.</p>
                
                <p><strong>Challenge 4 - Computational Efficiency:</strong> Naive pixel-by-pixel processing is slow.</p>
                <p><strong>Solution:</strong> Vectorized operations using numpy for faster processing of large images.</p>
            </div>
        </section>

        <!-- What I Learned -->
        <section class="section">
            <h2 class="section-title">What I Learned</h2>
            <div class="highlight">
                <h3>Most Important Insight</h3>
                <p>
                    The most important thing I learned from this project is how <strong>projective geometry</strong> provides 
                    a powerful mathematical framework for understanding and manipulating images. The homography matrix elegantly 
                    captures the relationship between different views of the same scene, enabling us to warp, align, and blend 
                    images in ways that match how cameras actually capture the world.
                </p>
                <p>
                    What struck me most was the connection between the abstract mathematics (solving systems of linear equations) 
                    and the concrete visual results (seamless panoramas). The fact that we can take point correspondences, 
                    set up a linear system, solve it, and get a transformation that perfectly aligns complex 3D scenes is 
                    remarkable. This project also highlighted the importance of careful implementation details - proper 
                    interpolation, coordinate system management, and blending strategies are crucial for high-quality results.
                </p>
            </div>

            <div class="approach-section">
                <h3>Technical Skills Gained</h3>
                <ul>
                    <li><strong>Homography Computation:</strong> Understanding and implementing the mathematics of projective transformations</li>
                    <li><strong>Image Warping:</strong> Implementing inverse warping with multiple interpolation methods from scratch</li>
                    <li><strong>Coordinate Systems:</strong> Managing different coordinate frames and transformations between them</li>
                    <li><strong>Blending Techniques:</strong> Implementing weighted averaging for seamless image composition</li>
                    <li><strong>Numerical Stability:</strong> Handling edge cases, boundary conditions, and numerical precision issues</li>
                    <li><strong>Debugging Visual Algorithms:</strong> Developing intuition for what different types of errors look like visually</li>
                </ul>
            </div>

            <div class="approach-section">
                <h3>Practical Applications</h3>
                <p>This project demonstrated real-world applications of computer vision:</p>
                <ul>
                    <li><strong>Panoramic Photography:</strong> Creating wide-angle views from multiple photos (like smartphone panorama mode)</li>
                    <li><strong>Document Scanning:</strong> Rectifying perspective-distorted documents to frontal views</li>
                    <li><strong>Augmented Reality:</strong> Understanding how to overlay virtual content on real-world surfaces</li>
                    <li><strong>3D Reconstruction:</strong> Foundation for structure-from-motion and multi-view geometry</li>
                    <li><strong>Image Stitching:</strong> Creating large composite images from multiple sources</li>
                </ul>
            </div>
        </section>

        <footer>
            <p>CS 180 - Computer Vision | Project 3: Image Warping and Mosaicing</p>
            <p>Exploring projective geometry, homographies, and panoramic image creation</p>
        </footer>
    </div>
</body>
</html>
